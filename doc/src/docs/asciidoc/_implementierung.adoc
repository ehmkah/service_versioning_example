== Welche Pattern kann ich für eine explizite Versionierung verwenden?

=== Anbieten des Services

=== URI Versioning

[%step]
* Rest und SOAP
* Beispiel http://www.ehmkah.de/v1/service
* Beispiel http://www.ehmkah.de/v2/service
* Vorteil: für SOAP fühlt sich natürlich an
* Nachteil: Passt nicht zu REST Paradigma

[NOTE.speaker]
--
* Nachteil: siehe http://www.baeldung.com/rest-versioning
--

=== URI Versioning (DEMO)

* DEMO (soap_service_impl_v1)
[source, java]
----
@Bean("endpointServiceV1")
  public Endpoint endpointServiceV1(SpringBus springBus) {
    EndpointImpl result = new EndpointImpl(springBus, serviceV1);
    result.setWsdlLocation("classpath:/wsdl/serviceDefinitionV1.wsdl");
    result.publish("/v1/service");

    return result;
  }
----

=== Media Type Versioning

* nur REST
* Beispiel: Header enthält individuellen Mediatype, "Accept": "application/vnd.ehmkah.app-1.0+json"
* Fehler, wenn es nicht passt 406 Not Acceptable

=== Media Type Versioning (DEMO)

* DEMO (rest_service_impl_media_type_versioning)
[source, java]
----
@RequestMapping(method = RequestMethod.GET, produces = "application/vnd.ehmkah.app-1.0+json")
  public ResponseEntity<List<Object>> list(
          @ApiParam(value = "Tags used to filter the result")
  ...
----

=== Unsere Entscheidung

* URI-Versioning
* Grund: viele SOAP Service, Rest Service sind noch nicht ressourcenorientiert

=== Implementieren des Services

=== Mehrfaches Deployen eines Services

[%step]
* Wenn ein Service zwei Versionen implementiert, können einfach beide Versionen gestartet werden
* Vorteile: funktioniert out of the box
* Nachteile: Kosten und Skalierung des Services

* DEMO

=== Code duplizieren

[%step]
* Businesscode wird vollständig kopiert

* DEMO

=== Adapterpattern zwischen Service Versionen (Klassendiagramm)

image::classDiagramConverter.png[background]

[%step]
* empfholen ein reichhaltiges Domainmodel bei grossen Schnittstellen AKA AKM!!), das nicht nach aussen gegeben wird
* wir haben keines konvertieren auf neueste Version des Services (langsameres löschen)
* muss vollständig sein (vereinfacht die Unterstüzung verschiedener Version immens)
* besonders nützlich beim löschen, da bei Konvertierung auf neue Schnittstellenversion Informationen gelöscht werden
können


=== Adapterpattern zwischen Service Versionen (Sequenzdiagram)

image::sequenceConverter.png[background]



=== Adapterpattern zwischen Versionen eines Services (Modelmapper)

[%step]
* konvertiert zwischen einer alten Version zu einer neuen Version
* Vorteil: für einfache Schnittstellen OK, da schnell aufgesetzt
* Nachteil: Probleme bei Typhierachien
* Nachteil: Automatismus des Mappings teilweise nicht durchschaubar
* Nachteil: Manuelle Anpassungen am Mapping kompliziert
* Nachteil: Teilweise Performanceprobleme
* Nachteil: COnvertierung müsste getestet werden

[NOTE.speaker]
--
* War unser erster Versuch (mit Modelmapper, dozer)
--

=== Adapterpattern zwischen Versionen eines Services (Modelmapper)

.Converter.map
[source,java]
----
private ModelMapper modelMapper = new ModelMapper();

    public com.ehmkah.services.gardening.RequestType map(RequestType requestV1) {
      com.ehmkah.services.gardening.RequestType result =
      modelMapper.map(requestV1, com.ehmkah.services.gardening.RequestType.class);

      return result;
    }
----


=== Adapterpattern zwischen Versionen eines Services (händisch)

[%step]
* TODO: Abbildung wie COnverter funktioniert
* konvertiert zwischen einer alten Version zu einer neuen Version
* Vorteil:
* Nachteil:

[NOTE.speaker]
--
* wir generieren den Mapper mit Javapoet und Java Reflektions
* passen an, wenn generiertes Mapping nicht passt
--

=== Adapterpattern zwischen Versionen eines Services (händisch)

.Converter.map
[source,java]
----
public com.ehmkah.services.gardening.RequestType map(RequestType requestV1) {
    com.ehmkah.services.gardening.RequestType result =
    new com.ehmkah.services.gardening.RequestType();
    result.setSpeciesOne(requestV1.getSpeciesOne());
    result.setSpeciesTwo(requestV1.getSpeciesTwo());

    return result;
  }
----

=== Adapterpattern zwischen Versionen eines Services (händisch)

* Einsatz eines Generators (und manuelles nachziehen der Änderungen)

=== Soap Message dispatcher?
und noch so nen anderes Ding von IBM /ORacle???